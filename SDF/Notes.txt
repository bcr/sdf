05/17/2006

This was the first cut I made of SDF. Basically getting up to speed with the NUnit environment and the various regex features of C#. There are two main things I futzed around with for this version:

* I/O redirection. In order to measure how well things were going, I wanted to capture standard output. This worked out pretty well. The main thing that threw me was that System.Out is a read-only property (I tried assigning a new TextWriter to Console.Out and was denied). Turns out you have to use Console.SetOut to redirect. After I did that, things worked out great. I made a helper class to do this hooking, overriding ToString on the class to give back the data that has been written so far.

* Regular expressions. In order to process directives, I needed some way to parse them. The Regex class seems to work great. One thing I found interesting when working with this is that I could use mnemonic names to refer to the various pieces of each directive. So the regex:

Regex regex = new Regex(@"\s*(?<expression>\S+)(\s+(?<name>[^ \t=]+)\s*=\s*'(?<value>[^']+)')*");

gives me a hand because it allows me to pick through the resulting match groups by name. Extracting the name of the expression for instance is:

string expression = match.Groups["expression"].ToString();

and each of the name / value pairs for the arguments are in the "name" and "value" groups. Shoving those in a Hashtable was trivial:

Group names = match.Groups["name"];
Group values = match.Groups["value"];

Hashtable arguments = new Hashtable(names.Captures.Count);

for (int counter = 0;counter < names.Captures.Count;++counter)
{
	arguments[names.Captures[counter].ToString()] = values.Captures[counter].ToString();
}

so I'm pretty pleased with that.

I'm also pretty happy with the ability to use strings in a switch statement:

switch (expression)
{
	case "Print":
		Console.WriteLine(arguments["message"]);
		break;
		
	case "PrintUpper":
		Console.WriteLine(((string) arguments["message"]).ToUpper());
		break;
}

I don't think this will end up in the final code, but it was cool to mess with. But the Print and PrintUpper expressions are a good start to getting a feel as to how this is going to shape up. The unit tests are concise, and I use the I/O redirection to grab output and make sure it's what I expect:

[Test]
public void TestPrint()
{
	SDF.Eval("Print message='Hello, world'");

	Assert.AreEqual("Hello, world\n", this.output.ToString());
}

[Test]
public void TestPrintUpper()
{
	SDF.Eval("PrintUpper message='Hello, world'");

	Assert.AreEqual("HELLO, WORLD\n", this.output.ToString());
}

Fun stuff. I think tomorrow I'm going to mess with creating implementation classes for Print and PrintUpper. I'm thinking something along the lines of:

[SDFExpression]
class Print
{
    [SDFName]
    public string Name
    {
        get
        {
            return "Print";
        }
    }
    
    [SDFEvaluate]
    public void Evaluate(Hashtable arguments)
    {
        Console.WriteLine(arguments["message"]);
    }
}

I don't know whether or not I'm going to use class, property and method attributes to flag these, or whether I should just use a consistent naming convention. I'm pretty sure that [SDFExpression] will survive to mark classes that implement expressions, but I'm not sure that [SDFName] and [SDFEvaluate] will survive, since I don't think it's too constraining to just make those well known names. NUnit uses this pattern for their [SetUp] and [TearDown] attributes:

[SetUp]
public void SetUp()
{
	this.output = new StandardOutputRedirector();
}

[TearDown]
public void TearDown()
{
	this.output.Unhook();
}

and I'm not sure I agree. It might be nice to have the flexibility to call the SetUp method "George" or the TearDown method called "Martha", but is it really useful? I think I'm talking myself out of it.

Another thing is that I don't know if I'll ultimately end up sending down a Hashtable to Evaluate, or whether I'll use properties. You can see for Print how you could implement it as:

[SDFArgument]
public string message
{
    get
    {
        return this.message;
    }
    
    set
    {
        this.message = value;
    }
}

and then skip sending down the hashtable to the Evaluate method. You can also see how this might help come up with syntax validation -- for Print, the "message" argument is required. So you can have a constraint expressed in the attribute for the property. Something like:

[SDFArgument(Required=true)]

would indicate that the argument is required. Not sure yet. And I'm not sure enough about how attributes work to know if that's legal syntax. I definitely like it better than:

[SDFArgument(true)]

that is, it's more expressive to indicate exactly what's true instead of being position dependent and having to look up the attribute syntax.

Yeah, I think I'm talking myself into that. We'll see how it comes out, but I think it's likely that I'm going to use properties to store arguments, with attributes to indicate predicates and drive syntax validation. More complex interdependencies might be hard -- I guess we'll see when we get there. For instance, how do you express a constraint that the argument must be an IP address? Is it something like:

[SDFArgumentRegexConstraint(@"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}")]

or do you allow extension attributes:

[SDFArgumentIPAddressConstraint]

One thing I'm not sure I have right now in Mono is generics. Note that the Hashtable is untyped. It seems that Hashtable<string,string> would make me feel better. But my goal right now is to be Mono-compatible to get some cross-platformability. Because as much as I have both Parallels and Boot Camp installed with Windows XP, I don't really want to work in Windows for a day-to-day environment. Not to start a religious war or nuthin'. I do know that Mono was "workin' on it", I just don't know enough to use it yet.

Some random thoughts:

* The parser might need to be smarter about Unicode. I'll jump off that bridge when I refactor parsing into its own world and give it a robust set of tests.

* I wonder how documentation is going to work. Like I don't know anything about how the docs generation works in C# -- should I do something like:

/// (docs for Print command goes here in XML)
[SDFExpression]
public class Print
.
.
.

or should it be:

[SDFDescription("(docs for Print command goes here in XML)")]

If the latter, then I can use that for both the expression description as well as the argument descriptions.